# 開発者はインデックスを知る必要がある
SQLの抽象化は優れているが、パフォーマンスの問題にたどり着く時この抽象化は逆効果
極論開発者が知るべきことは、*どのようにインデックスを貼るか*に尽きる。

当書では最も重要なB Tree Indexのみを取り上げる。

## 構成
- 1. インデックスの内部構造を理解する
- 2. WHERE句の特徴
- 3. パフォーマンスとスケーラビリティ
- 4. 結合処理
- 5. データのクラスタリング
- 6. ソートとグルーピング
- 7. 部分的結果
- 8. 挿入、削除、更新
- 付録. 実行計画


# 1. インデックスの内部構造
- インデックス
  - create indexで作成される
  - 独自のディスク領域を必要とする
  - インデックスを貼られたテーブルのデータを保持する。
    - つまりインデックスは純粋に冗長な構造である
  - その名の通り、書籍の最後についている索引に似ている
    - そのためその場所を必要とし、冗長で、別の場所に保存されている本当の情報を参照するだけであるという特徴はky法痛している。

索引や電話帳のように、すべての要素が予め決められた順番に並んでいるため検索が高速
しかし追加や削除をするときにインデックスの順序を保つのが大変。
それを解決するためにデータベースは2つのデータ構造を組み合わせてこれらの問題に対処している。
それらが、*双方向連結リスト* と *検索木* である。これらの2つのデータ構造でほとんどのデータベースのパフォーマンスの特性の説明がつく。

## インデックスリーフノード
インデックスの最も重要な目的は、インデックスを貼ったデータに対して順序をつけてアクセスできるようにすること。
しかし実際のところINSERTがデータを挿入する際に、正しい順番のところに差し込むのは不可能。後続するデータをすべて後ろにずらさなければならないから。これは非常に時間のかかる処理。この問題への対策として、*メモリ上の物理データの並び順とは独立して、論理的な順序付けをつくる。*

論理的な順序付けは双方向連結リストでつくる。これによりポインタを変更するだけでデータの挿入が可能になる。

![インデックスリーフノード](https://gyazo.com/c567c63b342ae77cdc2ef27c34ee7054)

インデックスの順序は2つのレベルで管理される。
インデックスリーフノードと呼ばれる単位。これはデータベースが扱える最小の格納単位であるデータベースブロック or ページという単位で保存される。すべてのインデックスブロックは同じサイズになっていて、一般的には数KB。データベースは各ブロック内のスペースを使えるだけつかってインデックスを詰め込む。

このリーフノード内の順序と、リーフノードを双方向連結リストでつないだ順序の2つのレベルで管理されている。


インデックスとちがってテーブルのデータ自体はヒープ構造で保存されておりソートはされない。

## 検索ツリー(Bツリー)
双方向連結リストで保存されたインデックスリーフノードを探す時、上からたどってるようじゃ遅い。
のでバランス検索木を用いている。

![B Tree](https://gyazo.com/ed232e1cc6bba977e2db7606e889d063)

![B Treeの走査](https://gyazo.com/cb87281f950784307072fabedf7c2939)

リーフノード数の増加に比べてツリーの深さの増大は非常に遅い。
数百万レコードのインデックスのツリーの深さは4あるいは5。深さが6に達することはめったにない。
SEE: 対数的スケーラビリティ


## 遅いインデックス Part1
木の走査は効率がいい一方で、それでもインデックスによる検索が期待するほど高速でないケースがまだ存在する。
- リーフノードチェーンをたどる必要があるケースがあるため
  - ある値を探すとき、1つの値を見つけたとして、次のリーフノードチェーンにもその値がある可能性はある。
  - のでリーフノードチェーンの走査も必要
- テーブルへのアクセス
  - 1リーフノードが数百のエントリを保持することがある。対応するテーブルデータは通常たくさんのテーブルブロック(ページ)に分散して保存されている。ここへのアクセスが発生してしまう。

インデックスによる検索は
- 1. ツリーを走査し
- 2. リーフノードチェーンをたどり
- 3. テーブルからデータを読み出す
という3ステップで行われる。

ツリーの走査のみインデックスの深さによってアクセスするブロックの数に限りがある(多くて4~6ぐらい)
一方で、後続する2つのステップは大量のブロックにアクセスする必要があるケースが発生しうる。

インデックスが遅いと言われるときに、そこには誤解があって、インデックスによる検索が木の走査だけで行われるものではない。インデックスによる検索が遅いのは「壊れた」あるいは「アンバランスな」木が悪い。

OracleのDBではどのようにインデックスが使われるかを調べることができる
- INDEX UNIQUE SCAN
  - 木の走査しか行わない
  - ユニーク制約により検索条件が必ず1つしかないことが確実な場合にこの方法をつかう
- INDEX RANGE SCAN
  - 一致するすべてのエントリを探すために木の走査に加えてリーフノードチェーンをたどった検索も行なう
  - 検索条件に対して複数のエントリが存在する可能性がある場合の代替策
- TABLE ACCESS BY INDEX ROWID
  - テーブルから行を読み出す
  - 直前に行われたインデックススキャンの結果から、一致すレコードを読み出すために行われる

INDEX RANGE SCANは、インデックスのかなり大きな割合を読み込む可能性があることに注意。さらに各行ごとにテーブルアクセスが必要であることをかんがえると、インデックスをつかっていてもクエリは遅くなる。
  


## 対数的スケーラビリティ
TBL

## 
