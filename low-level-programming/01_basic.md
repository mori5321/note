# Chapter1. コンピュータアーキテクチャの基礎
## 1.1 コアアーキテクチャ
### 1.1.1 計算モデル
プログラマの仕事とは、アルゴリズムとその実装を構築すること
つまり、あるアイディアをつかみ、次にコーディングする

ある新しい観念を記述するのに、われわれはそれとは異なるより単純な観念を使う。
説明はピラミッド型になる。
しかし、説明のピラミッドは無限に構築できない(説明は有限でなければならない)。
基本となる観念が必要。

行動アルゴリズムの構築はその構成要素となる「基本的な行動」の集合を定義しない限り不可能。

「計算モデル」(model of computation) は基本的な演算(basic operations)とそれぞれのコストの集合である。

### 1.1.2 フォン・ノイマン・アーキテクチャ  

- メモリにはビットだけが保存される。ビットは情報の単位で、0または1に等しい値を持つ
- メモリには、コード化された命令(encoded instruction)と、操作の対象となるデータの両方が保存される。コードとデータを区別する手段はなく、どちらも実際にはビット列である。
- メモリは、複数のセル(cell)に入れて組織化し、ラベルとして、順番にインデックスを付ける。
- プログラムは次々にフェッチされる命令群で構成される。命令の実行は特別なジャンプ命令を実行しない限りシーケンシャルに行われる。


アーキテクチャは計算モデルと違って、必ずしも命令集合を厳密に定義するわけではない。

Note: メモリの状態とレジスタの値で、(プログラマから見た)CPUの状態を完全に記述できる。命令を理解することは、メモリとレジスタに対する、その効果を理解することを意味する。



### 1.2 進化
### 1.2.1 フォン・ノイマン・アーキテクチャの欠点
- Interactiveでない
- マルチタスクに適していない
- 誰もがどんな種類の命令でも実行できる

### 1.2.2 Intel 64 アーキテクチャ

### 1.2.3 アーキテクチャの拡張
Intel 64には、フォン・ノイマン・アーキテクチャからの複数の拡張が組み込まれている。
以下は重要なもの。

- レジスタ群
  - 応答時間が非常に短い
  - CPUチップ状に直接置かれたメモリセル
    - レジスタへのアクセスにはバスを使わない
- ハードウェアスタック
  - スタックを実現する
  - 特殊な命令 + スタックの最後の要素を指し示す1つのレジスタによって、メモリ上に実装する
  - ローカル変数の保存や、関数コールのシーケンスを実装するのにも使われる。
- 割り込み
  - プログラムの実行順序を変更できる
  - あるシグナルをキャッチすると、プログラムの実行がサスペンドされ、いくつかのレジスタが保存され、CPUはその状況をしょりするための特別なルーチンの実行を開始する
  - 典型的な状況例
    - 外部デバイスからのシグナル
    - ゼロによる除算
    - 無効な命令
    - 非特権モードで、特権命令を実行しようとしたとき
- プロテクションリング
  - レベル0 ~ レベル3までのリングを持つ
  - 各レベルで許可される命令の集合を定義する
- 仮想メモリ


*Refs*
Intel 64 and IA-32 Architectures Software Developer's Manual
このドキュメントのVolume2は命令セットを完全にカバーしている


## 1.3 レジスタ
ノイマン型コンピューターにおける計算で、CPUとメモリ間のデータ交換は決定的に重要。
命令をメモリからフェッチする必要があり、オペランドもメモリからフェッチする必要がある。
ある種の命令では結果もメモリに保存される。これがボトルネックとなり、CPUがメモリチップからのデータ応答を待つときにCPUタイムが浪費される。

その待ちを防ぐためにレジスタがある。

一般にプログラムはほとんどの場合使用するメモリセルの集合が十分に小さくなるよう書かれる。
これはほとんどのケースでCPUがレジスタを相手にするようにプログラムを書けることを意味する。

レジスタはトランジスタがベースだが(SRAM)、メインメモリのセルにはキャパシタが使われている(DRAM)。

プログラムは一般的にある特定の性質を持つようにかかれる。それはプログラムの一般的なパターン(loop, function, データの再利用)を使うことの結果であって自然の法則ではない。
- 参照の局所性(locality of reference)
  - 時間的局所性(temporal locality)
    - あるアドレスへのアクセスが時間的に集中しやすいという性質
  - 空間的局所性(spatial locality)
    - アドレスXをアクセスした後にはそのXに近いメモリがアクセスされやすいという性質


### 1.3.1 汎用レジスタ
- ほとんどの場合にプログラマが相手にするのは汎用レジスタ
- 64ビットレジスタで、r0...r15という名前を持つ
- 前半の8個は別の名前で呼ばれて、その名前はある酒の特別な命令で持つ意味を表している
- 例
  - r0 = rax
    - accumulatorとして算術命令で使われる。
  - r3 = rbx
    - ベースレジスタ
  - r1 = rcx
    - c は cycle(回数)を意味する。ループの回数に使われる。
  - r2 = rdx
    - 入出力処理の間、データ(data)を格納する
  - r4 = rsp
    - スタックポインタ。ハードウェアスタックのもっとも上にある要素のアドレスを格納する
  - r5 = rbp
    - スタックフレームのベースポインタ
  - r6 = rsi
    - ストリング操作コマンド(ソース側インデックス)
  - r7 = rdi
    - ストリング操作コマンド(デスティネーション側インデックス)

rspとrbpは使いたくない。スタックとスタックフレームを壊してしまうから。



d - ダブルワードで下位32ビット
w - ワードで下位16ビット
b - バイトで下位ビット

r7 -> レジスタr7の64ビット(4バイト)
r7b -> レジスタr7の最下位バイト(8bit)
r7w -> レジスタr7の下位2バイト(16bit)
r7d -> レジスタr7の下位3バイト(32bit)


## 1.4 プロテクションリング
Level0とLevel3しかほとんどつかわれない。

